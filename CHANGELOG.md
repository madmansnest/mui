## [Unreleased]

### Fixed
- Fixed Ctrl+w window commands not working in new tabs
  - Previously, Ctrl+w w/h/j/k/l/s/v/c/o commands would use the first tab's WindowManager even after switching tabs
  - `@window_command` was memoized with the initial tab's WindowManager
  - Now creates WindowCommand with current tab's WindowManager on each invocation

## [0.4.0] 2025-12-19

### Added
- `<S-Tab>` (Shift+Tab) notation support in keymap configuration:
  - Added `s-tab` and `btab` to `SPECIAL_KEYS` mapping to `:shift_tab` symbol
  - `normalize_input_key()` now handles `KEY_BTAB` (353) from Curses
  - Enables tab navigation keymaps like:
    ```ruby
    Mui.keymap :normal, "<Tab>", ->(ctx) { ctx.editor.tab_manager.next_tab }
    Mui.keymap :normal, "<S-Tab>", ->(ctx) { ctx.editor.tab_manager.prev_tab }
    ```
- Function definition name highlighting for 6 languages:
  - Ruby: `def hello` highlights `hello` (lookbehind pattern `(?<=def )`)
  - Go: `func main()` highlights `main` (lookbehind pattern `(?<=func )`)
  - Rust: `fn calculate()` highlights `calculate` (lookbehind pattern `(?<=fn )`)
  - JavaScript: `function add()` highlights `add` (post-process after `function` keyword)
  - TypeScript: `function fetchData()` highlights `fetchData` (post-process after `function` keyword)
  - C: `int main()` highlights `main` (lookahead pattern for identifier before `(`)
  - New token type `:function_definition` mapped to `syntax_function_definition` color scheme element
  - All 8 themes updated with `syntax_function_definition` style (same color as `syntax_method_call`)
- Improved mui default theme with 256-color palette:
  - Eye-friendly gray-based color scheme using 256-color palette
  - 19 new `mui_*` colors in `EXTENDED_COLOR_MAP` (mui_bg, mui_fg, mui_comment, etc.)
  - Syntax highlighting follows Vim standard highlight groups (Comment, Constant, Identifier, Statement, PreProc, Type, Special)
  - 8-color fallbacks for all mui colors
- Improved all bundled themes to match their original color schemes:
  - Solarized Dark/Light: Adjusted visual selection, operators, and diff colors
  - Monokai: Fixed comment color to olive gray (#75715e), added `monokai_comment` color
  - Nord: Adjusted status line and constant colors to match Nord palette
  - Gruvbox: Adjusted identifier and keyword colors
  - Dracula: Adjusted visual selection and symbol colors
  - Tokyo Night: Adjusted operator and constant colors
- Added LSP diagnostics and floating window styles to all themes:
  - `diagnostic_error`, `diagnostic_warning`, `diagnostic_info`, `diagnostic_hint`
  - `floating_window`
- 256-color support stabilization:
  - Environment capability detection (`Curses.has_colors?`, `Curses.colors`, `Curses.color_pairs`)
  - Automatic 8-color fallback for terminals without 256-color support
  - `FALLBACK_MAP` to map extended colors to nearest basic 8-color equivalents
  - LRU cache for color pairs to prevent pair exhaustion
  - Automatic eviction of oldest pairs when limit is reached
  - Backward compatible: `ColorManager.new` without adapter assumes 256 colors
  - `ColorManager#supports_256_colors` to check color capability
  - `TerminalAdapter::Base#has_colors?`, `#colors`, `#color_pairs` interface methods

### Fixed
- Fixed text corruption after closing floating window or completion popup:
  - Japanese/CJK multibyte characters were not displaying correctly after popup closed
  - Added `touchwin` method to force complete screen redraw using `Curses.stdscr.redraw`
  - `FloatingWindow` now tracks `last_bounds` and `needs_clear` flag
  - `InsertCompletionState` now tracks `needs_clear` flag
  - Editor calls `touchwin` when popup is closed to restore corrupted characters

### Changed
- Improved search performance for large files:
  - Added row-based index (`row_index`) to search match cache for O(1) lookup
  - `matches_for_row()` now uses hash lookup instead of linear search
  - Before: O(M × visible_rows) per frame, After: O(visible_rows) per frame
- Improved navigation performance for large files (G, gg commands):
  - Added smart scroll jump for cursor movements over 100 rows
  - Directly calculates scroll position instead of iterating line by line
  - Before: O(n) where n = cursor distance, After: O(1)

## [0.3.0] - 2025-12-15

### Added
- Additional syntax highlighting for 7 languages:
  - Go: keywords, types, constants, raw strings (backtick), block comments
  - Rust: macros (`println!`), lifetimes (`'a`), attributes (`#[derive]`), doc comments (`///`), raw strings (`r#"..."#`)
  - JavaScript: template literals, regex literals, BigInt (`123n`), ES6+ keywords (`const`, `let`, `async`, `await`)
  - TypeScript: extends JavaScript with type keywords (`interface`, `type`, `enum`, `declare`, `abstract`)
  - Markdown: headings, emphasis (`*italic*`, `**bold**`), code blocks, links, lists, blockquotes
  - HTML: tags, attributes, comments (`<!-- -->`), DOCTYPE, entities (`&amp;`)
  - CSS: selectors (`.class`, `#id`, `:pseudo`), properties, hex colors, @rules, functions (`calc`, `rgb`, `var`)
  - Supported extensions: `.go`, `.rs`, `.js`/`.mjs`/`.cjs`/`.jsx`, `.ts`/`.tsx`/`.mts`/`.cts`, `.md`/`.markdown`, `.html`/`.htm`/`.xhtml`, `.css`/`.scss`/`.sass`
- Multi-key sequence and leader key support (Vim-compatible):
  - Leader key: `Mui.set :leader, "\\"` (default: backslash)
  - `<Leader>` notation: `Mui.keymap :normal, "<Leader>gd" do ... end`
  - Multi-key sequences: `<Leader>ff`, `<C-x><C-s>`, etc.
  - Special key notation: `<Space>`, `<Tab>`, `<CR>`, `<Enter>`, `<Esc>`, `<BS>`
  - Control key notation: `<C-x>`, `<Ctrl-x>`, `<C-S-x>` (Ctrl+Shift)
  - Shift key notation: `<S-x>`, `<Shift-x>`
  - Timeout setting: `Mui.set :timeoutlen, 1000` (milliseconds)
  - All modes supported: Normal, Insert, Visual, Command, Search
  - Built-in commands (dd, dw, gg, etc.) take priority over plugin keymaps
  - Partial match waiting: typing `<Leader>g` waits for more keys if `<Leader>gd` is registered
  - Exact match with longer possibilities: waits for timeout before executing
  - Backward compatible with single-key keymaps
- External shell command execution (`:!cmd`):
  - `:!echo hello` to run shell commands asynchronously
  - Output displayed in `[Shell Output]` scratch buffer (readonly)
  - stdout/stderr/exit status formatted and displayed
  - "Running: cmd" message shown during execution
  - Subsequent `:!cmd` updates existing scratch buffer (doesn't create new windows)
  - Supports pipes, redirects, and all shell features via Open3
  - Empty command (`:!` or `:!   `) shows error: "E471: Argument required"
- Case-insensitive command completion:
  - `:git` now matches `:Git`, `:lsp` matches `:LspHover`, `:LspDefinition`, etc.
  - Original command case is preserved in completion results
  - Only applies to command completion (file path completion remains case-sensitive)
- Command history with persistence:
  - Up/Down arrow keys navigate through command history in command mode
  - History saved to `~/.mui_history` (persists across sessions)
  - Maximum 100 entries stored
  - Duplicate commands move to most recent position
  - Empty commands are not added to history
  - Current input is preserved when browsing history (restored with Down at end)

### Fixed
- Fixed long lines not displaying correctly by implementing line wrapping
  - Lines exceeding screen width are now automatically wrapped to next screen line
  - Unicode width aware wrapping (Japanese characters count as 2 width)
  - Removed broken horizontal scrolling (`scroll_col`) in favor of wrap mode
  - Cursor position correctly calculated across wrapped lines
  - Selection and search highlights work correctly across wrap boundaries
  - Added `WrapCache` for performance optimization (content-based caching)
  - Added `WrapHelper` module for wrap calculations
- Fixed search returning "Pattern not found" after switching buffers via `:e`
  - `execute_search` was using `@buffer` (initial buffer) instead of `buffer` method (current buffer)
  - Now correctly searches in the current buffer after buffer switch
- Search highlight now recalculates correctly when switching buffers via `:e`
  - Previously, search highlight from old buffer remained visible in new buffer
  - Now calls `find_all_matches` on buffer switch to recalculate matches (Vim-compatible behavior)
  - Search pattern is preserved, only match positions are updated for new buffer content
- Search highlight now recalculates correctly when opening files via `:sp`, `:vs`, `:tabnew`
  - Previously, search highlight was not calculated for new buffers opened with split/tab commands
  - Now calls `find_all_matches` when path is specified, consistent with `:e` behavior
- Improved Escape key response time in Insert mode
  - Set `ESCDELAY = 10` to reduce escape sequence detection delay from 1000ms to 10ms
  - Use `timeout = 0` instead of `nodelay` for `getch_nonblock`
- Insert mode completion now closes when pressing Left/Right arrow keys
  - Previously, arrow keys would move cursor but completion popup remained open
  - Now matches Vim behavior: completion closes on cursor movement
- Undo/Redo now works correctly for buffers opened via `:e`, `:sp`, `:vs`, `:tabnew`
  - Previously, buffers opened with these commands had no UndoManager set
  - Each buffer now gets its own UndoManager (Vim-compatible: independent undo history per buffer)
  - Handlers now use dynamic `undo_manager` reference to support buffer switching
- Fixed screen remnants after `:e` command when new file has fewer lines
  - Previously, lines from the old buffer would remain visible below the new content
  - Now explicitly clears lines beyond buffer content during render
- Fixed background color not applied to lines beyond buffer content
  - Previously, when opening a file with fewer lines than the visible height, lines beyond buffer were rendered without background color (transparent)
  - Now uses `put_with_style` with `:normal` color scheme to ensure consistent background color
- Plugin commands now appear in command completion suggestions
  - Previously, commands registered via `Mui.command` were not shown in Tab completion
  - `CommandCompleter` now includes plugin commands from `Mui.config.commands`
- Multi-line paste now undos as a single action (Vim-compatible)
  - Previously, pasting multiple lines would undo one line at a time
  - Now uses `begin_group`/`end_group` to group all paste operations into a single undo unit
  - Fixed direct array assignment to use `replace_line` for proper undo recording
- Search highlight now works correctly per buffer when switching tabs/windows
  - Previously, search matches from old buffer remained when using `gt`/`gT` or `Ctrl+W` commands
  - `SearchState` now caches matches per buffer (keyed by `object_id`) with lazy evaluation
  - Each buffer maintains its own match positions while sharing the global search pattern
  - Cache automatically invalidates when pattern changes or buffer content is modified
  - Vim-compatible behavior: search pattern is global, highlights are buffer-specific
- Plugin commands now recognized by CommandRegistry for alias configuration
  - Previously, `CommandRegistry#exists?` and `#find` only checked built-in commands
  - Now also checks `Mui.config.commands` for plugin-registered commands
  - Enables setting command aliases for plugin commands without errors
  - Built-in commands take precedence over plugin commands with the same name

## [0.2.0] - 2025-12-12

### Added
- Insert mode completion support for LSP:
  - `InsertCompletionState` class for managing LSP completion items
  - `InsertCompletionRenderer` for displaying completion popup below cursor
  - `Editor#start_insert_completion(items, prefix:)` API for plugins
  - `Editor#insert_completion_active?` to check completion state
  - Key bindings in Insert mode:
    - `↑` / `Ctrl+P`: Select previous completion
    - `↓` / `Ctrl+N`: Select next completion
    - `Tab`: Confirm and insert selected completion
    - `Esc`: Cancel completion popup
  - Popup automatically repositions above cursor if space is limited
  - Auto-trigger completion after `.`, `@`, and `::` characters
  - Uses LSP `textEdit` for precise text replacement
- Buffer word completion (`Ctrl+N` / `Ctrl+P` in Insert mode):
  - Collects words from current buffer as completion candidates
  - `BufferWordCache` class for high-performance word caching
  - Cache built once when entering Insert mode, updated incrementally on changes
  - Auto-triggers while typing (1+ character prefix)
  - Dynamic filtering: completion list updates as you type more characters
  - Excludes word at cursor position from candidates
  - Triggered when no LSP completion is active
- `InsertCompletion` autocmd event for plugins to hook into completion triggers
- `KeyCode::CTRL_N`, `KeyCode::CTRL_P`, and `KeyCode::CTRL_SPACE` constants
- `KeyHandler::Base#editor` helper method for accessing editor instance
- Insert mode plugin keymap support (allows plugins to define Insert mode key bindings)
- LSP configuration stub (`Mui.lsp` / `Mui::LspConfigStub`):
  - Allows `.muirc` to call `Mui.lsp { ... }` before mui-lsp gem is loaded
  - Stub stores configuration (preset servers via `use`, custom servers via `server`)
  - When mui-lsp gem loads, configurations are automatically migrated to real `ConfigDsl`
  - `Mui.lsp_server_configs` returns stored server configurations
- Floating window (popup) support:
  - `FloatingWindow` class for displaying temporary content like hover info
  - `editor.show_floating(content, max_width:, max_height:)` to show popup at cursor
  - `editor.hide_floating` to close the popup
  - Automatic positioning with screen bounds adjustment
  - Unicode box-drawing border characters
  - Scroll support for long content
  - Auto-close on any key press (Escape only closes without processing)
  - Configurable via `:floating_window` color scheme element
- Dynamic custom highlighter management for buffers:
  - `Buffer#add_custom_highlighter(key, highlighter)` to add named highlighter
  - `Buffer#remove_custom_highlighter(key)` to remove highlighter by key
  - `Buffer#custom_highlighter?(key)` to check if highlighter exists
  - `Window#refresh_highlighters` to rebuild line renderer after highlighter changes
  - Enables plugins to dynamically add/remove highlighting (e.g., LSP diagnostics)
- Interactive command execution support for plugins:
  - `TerminalAdapter#suspend` / `#resume` methods for temporarily exiting curses mode
  - `Editor#suspend_ui` block helper for safe UI suspension
  - `CommandContext#run_interactive_command(cmd)` to run external interactive commands (e.g., fzf)
  - `CommandContext#command_exists?(cmd)` to check if external command is available
  - Enables plugins to integrate with interactive CLI tools like fzf, less, etc.
- Custom highlighter support for buffers:
  - `Buffer#custom_highlighters(color_scheme)` method for buffer-specific highlighting
  - Window automatically applies custom highlighters from buffer
  - Enables plugins to provide syntax highlighting for special buffers (e.g., diff output)
- Diff highlighting color definitions:
  - Added `diff_add`, `diff_delete`, `diff_hunk`, `diff_header` to ColorScheme elements
  - All themes now include diff highlighting colors
- Incremental search (incsearch):
  - Search results highlight in real-time as you type
  - Cursor moves to first match while typing
  - Escape cancels search and restores original cursor position
  - Backspace updates search results incrementally
  - Works with both forward (`/`) and backward (`?`) search
  - Word completion popup shows matching words from buffer as you type
  - Tab/Shift+Tab to cycle through completion candidates
  - Completions are extracted from buffer content (identifiers and words)
- Word search commands (`*` and `#`):
  - Normal mode: `*` searches forward for word under cursor
  - Normal mode: `#` searches backward for word under cursor
  - Uses word boundaries (`\b`) for whole-word matching (Vim behavior)
  - Visual mode: `*`/`#` searches for selected text
  - Works in both Visual mode (`v`) and Visual Line mode (`V`)
  - Special regex characters are escaped for literal matching
  - Search state is updated so `n`/`N` continues to find matches
- Visual mode indent commands (Vim-compatible):
  - `>` to add indent to selected lines (shiftwidth spaces or tab)
  - `<` to remove indent from selected lines
  - Works in both Visual mode (`v`) and Visual Line mode (`V`)
  - Empty lines are skipped (Vim behavior)
  - Multiple lines indented as single undo group
  - Cursor moves to first selected line after operation
  - Configuration options: `shiftwidth` (default: 2), `expandtab` (default: true), `tabstop` (default: 8)
  - `reselect_after_indent` option (default: false): Keep selection after indent for continuous adjustment
- Reselect last visual selection (`gv` command):
  - `gv` in Normal mode restores the previous visual selection
  - Works with both Visual mode and Visual Line mode
  - Cursor moves to end of selection
  - Useful for repeating operations on the same selection (e.g., multiple indents)
- Asynchronous job execution system (JobManager):
  - `JobManager` class for managing background tasks with Thread + Queue
  - `Job` class with status tracking (pending, running, completed, failed, cancelled)
  - Thread-safe implementation with Mutex protection
  - `context.run_async { ... }` to run Ruby blocks asynchronously
  - `context.run_shell_command("cmd")` to run external shell commands via Open3
  - `context.jobs_running?` to check if any jobs are active
  - `context.cancel_job(id)` to cancel a running job
  - Callback support via `on_complete:` parameter
  - Autocmd events: JobStarted, JobCompleted, JobFailed, JobCancelled
  - Non-blocking event loop with polling for job results
- Scratch buffer support:
  - `editor.open_scratch_buffer(name, content)` to display read-only results
  - `context.open_scratch_buffer(name, content)` for plugins
  - Opens in horizontal split window
  - Ideal for displaying test results, linter output, etc.
- Readonly buffer protection:
  - `buffer.readonly` flag to mark buffers as read-only
  - Edit commands (`i`, `a`, `o`, `O`, `x`, `d`, `c`, `p`, `P`) blocked with error message
  - `:w` and `:wq` commands blocked on readonly buffers
  - Navigation and yank operations still allowed
- Command-line completion (real-time popup):
  - Auto-completion popup appears as you type in command mode
  - Command name completion for all Ex commands (`:w`, `:q`, `:tabnew`, etc.)
  - File path completion for file commands (`:e`, `:w`, `:sp`, `:vs`, `:tabnew`)
  - Tab to cycle forward through candidates and apply selection
  - Shift+Tab to cycle backward through candidates
  - Popup displays up to 10 candidates with scroll support
  - Completion styles configurable in all 8 themes (`completion_popup`, `completion_popup_selected`)
- Syntax highlighting for Ruby and C:
  - Token-based lexer architecture with extensible base class
  - Ruby lexer with support for: keywords, strings, comments, numbers, symbols, constants, instance variables (`@foo`, `@@bar`), global variables (`$stdout`), method calls (`.to_i`, `.each`)
  - C lexer with support for: keywords, strings, char literals, comments, numbers, preprocessor directives
  - Multiline comment support: Ruby `=begin`/`=end`, C `/* */`
  - Line-based token caching for performance
  - Language auto-detection from file extension (`.rb`, `.rake`, `.gemspec`, `.c`, `.h`, `.y`)
  - Syntax colors defined for all 8 built-in themes
  - Configurable via `set :syntax, true/false` in `.muirc`
- Tab page functionality (Vim-compatible):
  - Tab > Window hierarchy: each tab contains independent window layout
  - `:tabnew` / `:tabe` / `:tabedit` to create new tab
  - `:tabclose` / `:tabc` to close current tab
  - `:tabnext` / `:tabn` to go to next tab
  - `:tabprev` / `:tabp` to go to previous tab
  - `:tabfirst` / `:tabf` to go to first tab
  - `:tablast` / `:tabl` to go to last tab
  - `:Ntabn` / `:tabnext N` to go to specific tab (1-indexed)
  - `:tabmove N` / `:tabm N` to move current tab to position N
  - `gt` to go to next tab (wraps around)
  - `gT` to go to previous tab (wraps around)
  - Tab bar at top of screen with separator line
  - Tab bar colors configurable via color scheme (`tab_bar`, `tab_bar_active`)
  - `:q` closes window → tab → editor (Vim-like behavior)
- Window split functionality:
  - `:sp` / `:split` to split window horizontally (top/bottom)
  - `:vs` / `:vsplit` to split window vertically (left/right)
  - `:sp <filename>` / `:vs <filename>` to split and open file
  - `Ctrl-w h/j/k/l` to navigate between split windows
  - `Ctrl-w w` to cycle to next window
  - `Ctrl-w c` / `:close` to close current window
  - `Ctrl-w o` / `:only` to close all windows except current
  - `:q` / `:wq` / `:q!` in split window closes only that window (Vim-compatible)
  - `:e <filename>` opens file in current window only (doesn't affect other split windows)
  - Separator lines between windows with configurable colors
  - Command line area with configurable background color (no terminal transparency)
  - Each window has independent cursor position, scroll state, and buffer
- Japanese and multibyte character input support:
  - Full UTF-8 input handling in Insert mode via IME
  - Proper display width calculation for CJK characters (East Asian Width)
  - Cursor position correctly accounts for double-width characters
  - UTF-8 byte sequence assembly in terminal adapter
- Plugin system:
  - `Mui.use "gem_name"` to declare plugin gems
  - Lazy gem installation via `bundler/inline` on editor startup
  - Class-based plugins: `class MyPlugin < Mui::Plugin`
  - DSL-based plugins: `Mui.define_plugin(:name) { ... }`
  - Plugin API: `command`, `keymap`, `autocmd`
  - Plugin dependencies with topological sort for load order
  - CommandContext for plugin access to editor internals
- Autocmd event system:
  - 14 events: BufEnter, BufLeave, BufWrite, BufWritePre, BufWritePost, ModeChanged, CursorMoved, TextChanged, InsertEnter, InsertLeave, JobStarted, JobCompleted, JobFailed, JobCancelled
  - Pattern matching for file paths (e.g., `"*.rb"`)
  - `Mui.autocmd :BufEnter, pattern: "*.rb" do |ctx| ... end`
- Custom commands:
  - `Mui.command :name do |ctx| ... end`
  - Execute via `:name` in command mode
- Custom keymaps:
  - `Mui.keymap :normal, "key" do |ctx| ... end`
  - Per-mode key bindings
- Configuration file support:
  - `~/.muirc` for global settings
  - `.lmuirc` for local (per-project) settings
  - Local settings override global settings
  - Ruby DSL format: `Mui.set :colorscheme, "theme_name"`
- Color scheme system:
  - 256-color terminal support
  - Built-in themes: `mui` (default), `solarized_dark`, `solarized_light`, `monokai`, `nord`, `gruvbox_dark`, `dracula`, `tokyo_night`
  - Customizable UI elements: normal text, status line, search highlight, visual selection, line numbers, messages
- Search functionality:
  - `/` to search forward (supports regular expressions)
  - `?` to search backward (supports regular expressions)
  - `n` to jump to next match (respects search direction)
  - `N` to jump to previous match (reverses search direction)
  - Wrap-around search (continues from beginning/end of file)
  - Search match highlighting across visible lines
- Undo/Redo functionality:
  - `u` to undo last change
  - `Ctrl-r` to redo undone change
  - Vim-compatible undo granularity: Insert mode session as single undo unit
  - Support for all editing operations (insert, delete, change, visual mode operations)
  - Maximum 1000 undo history entries
- Vim-compatible named registers:
  - Named registers (`"a` - `"z`): 26 user-specified registers
  - Unnamed register (`""`): Default register
  - Yank register (`"0`): Stores last yank, not affected by delete
  - Delete history registers (`"1` - `"9`): Stores delete history, shifts on each delete
  - Black hole register (`"_`): Discards content without saving
  - Usage: `"ayy` (yank to register a), `"ap` (paste from register a)
- Delete/change operators now save to registers (Vim-compatible behavior):
  - `dd`, `dw`, etc. save deleted text to unnamed register and delete history
  - `cc`, `cw`, etc. save changed text to unnamed register and delete history
  - Visual mode `d`/`c` also save to registers
- Yank operator (`y`):
  - `yy` to yank current line
  - `y` + motion: `yw`, `ye`, `yb`, `y0`, `y$`, `ygg`, `yG`
  - `yf{char}`, `yt{char}`, `yF{char}`, `yT{char}` to yank to/till character
  - `y` in Visual mode to yank selection (character-wise and line-wise)
  - `yw` behaves like `ye` (yanks to end of word) matching Vim behavior
- Paste commands:
  - `p` to paste after cursor (character-wise) or below current line (line-wise)
  - `P` to paste before cursor (character-wise) or above current line (line-wise)
  - Multi-line character-wise paste support
- Register system for yank/paste operations
  - Default register for storing yanked text
  - Named registers support
  - Linewise flag to distinguish line-wise vs character-wise yanks
- TerminalAdapter abstraction layer for custom terminal implementations
  - `Mui::TerminalAdapter::Base` abstract base class defining the terminal interface
  - `Mui::TerminalAdapter::Curses` default implementation using Curses library
  - Users can create custom adapters by subclassing `Base` and passing to `Editor.new(adapter:)`
  - Example: `Mui::Editor.new(file_path, adapter: MyCustomAdapter.new)`
- Initial release of Mui, a Vim-like text editor written in Ruby
- Vim-like modal editing with five modes:
  - Normal mode: Navigation and text manipulation
  - Insert mode: Text input
  - Command mode: Ex commands
  - Visual mode (`v`): Character-wise selection
  - Visual Line mode (`V`): Line-wise selection
- Basic cursor movement with `h`, `j`, `k`, `l` and arrow keys in Normal mode
- Arrow key cursor movement in Insert mode
- Motion commands:
  - Word movements: `w` (word forward), `b` (word backward), `e` (word end)
  - Line movements: `0` (line start), `^` (first non-blank), `$` (line end)
  - File movements: `gg` (file start), `G` (file end)
  - Character search: `f{char}`, `F{char}`, `t{char}`, `T{char}`
- Text editing operations:
  - `i` to insert before cursor
  - `a` to append after cursor
  - `o` to open new line below
  - `O` to open new line above
  - `x` to delete character at cursor
  - Backspace to delete and join lines
- Delete operator (`d`):
  - `dd` to delete current line
  - `d` + motion: `dw`, `de`, `db`, `d0`, `d$`, `dgg`, `dG`
  - `df{char}`, `dt{char}`, `dF{char}`, `dT{char}` to delete to/till character
  - `d` in Visual mode to delete selection (character-wise and line-wise)
- Change operator (`c`):
  - `cc` to change current line (clear and enter Insert mode)
  - `c` + motion: `cw`, `ce`, `cb`, `c0`, `c$`, `cgg`, `cG`
  - `cf{char}`, `ct{char}`, `cF{char}`, `cT{char}` to change to/till character
  - `c` in Visual mode to change selection (character-wise and line-wise)
  - `cw` behaves like `ce` (changes to end of word, preserving space) matching Vim behavior
- Ex commands:
  - `:w` to save file
  - `:w <filename>` to save as
  - `:q` to quit (with unsaved changes protection)
  - `:q!` to force quit
  - `:wq` to save and quit
  - `:e` to reload current file
  - `:e <filename>` to open file (Vim-compatible: non-existent files open as new buffer)
  - `:{number}` to jump to specific line (e.g., `:10` jumps to line 10)
    - Line numbers are 1-indexed (`:1` = first line)
    - Out-of-range values are clamped (`:0` → first line, `:999` on 100-line file → last line)
    - Cursor moves to beginning of line (column 0)
- Curses-based terminal UI with:
  - Buffer management
  - Window with scrolling support
  - Status line display
  - Command line input
- Visual mode features:
  - Selection highlighting with reverse video
  - Toggle between Visual and Visual Line mode with `v`/`V`
  - All motion commands supported (h, j, k, l, w, b, e, 0, ^, $, gg, G, f, F, t, T)
  - Exit to Normal mode with `Esc`
- Comprehensive test suite for `Mui::Input` and `Mui::Editor` classes
  - Unit tests for Buffer, CommandLine, Input, Screen, Window, Selection, and Editor modes
  - Integration tests for component interactions
  - E2E tests with ScriptRunner DSL for Vim operation scenarios including Visual mode
- Test infrastructure with Curses mock and `MuiTestHelper` module

### Changed
- Reorganized test directory structure to follow standard gem conventions
  - Unit tests moved to `test/mui/`
  - Editor mode tests in `test/mui/editor/`
  - Integration tests in `test/integration/`
  - E2E tests in `test/e2e/`
- Refactored test files to use nested classes per method for better readability
- Improved syntax highlighting performance:
  - Use `\G` anchor for position-specific regex matching to avoid substring allocation
  - Pre-compile all regex patterns as class-level constants for one-time compilation at class load
  - Optimize event sorting in line renderer using array tuples instead of hash arrays
  - Add style resolution cache to avoid repeated hash merges
  - Reduce hash lookups in token cache by inlining cache validation
- Improved buffer change detection performance:
  - Added `Buffer#change_count` for O(1) change detection
  - Replaced `buffer.lines.hash` (O(n)) with counter comparison in `TextChanged` event trigger
- Improved buffer word completion performance:
  - Use `String#scan` with regex for fast word extraction instead of character-by-character iteration
  - Direct ASCII code comparison for word character detection instead of regex match per character

### Fixed
- Command-line completion Tab behavior:
  - First Tab now confirms current selection without cycling to next candidate
  - Second Tab and subsequent presses cycle through candidates
  - Previously, first Tab would skip the initially displayed candidate
- Command-line completion cursor position:
  - Cursor now moves to end of buffer after applying completion
  - Previously, cursor remained at old position after completion
- Plugin keymap handler now correctly uses active window's buffer instead of initial buffer
  - Fixes issue where buffer-specific keymaps didn't work in split windows
- Plugin keymap handler now properly returns handler result
  - Allows buffer-specific keymaps to conditionally pass through to built-in handlers
- Plugin keymap now correctly handles Enter key (Curses::KEY_ENTER)
  - Previously special key codes like Curses::KEY_ENTER (343) were not converted to keymap string
  - Now Enter key variants (CR, LF, KEY_ENTER) are all mapped to `"\r"` for plugin keymaps
- Auto-indent on newline in Insert mode
  - Pressing Enter preserves indentation from the current line
  - Leading whitespace (spaces and tabs) is automatically inserted on the new line
  - Whitespace-only lines are cleared when pressing Escape (Vim behavior)
- Register is now shared globally across tabs and split windows
  - Yank in one tab/window can be pasted in another
  - Previously each ModeManager had its own Register instance
- Visual mode operations now correctly use the active window's buffer
  - Fixed yank/delete/change/indent operations using stale buffer reference after tab or window switch
  - Operations now properly target the current active window's buffer
- Command mode cursor movement with arrow keys
  - Left/Right arrow keys now move cursor within command line
  - Previously arrow keys were interpreted as characters (e.g., Left inserted 'a')
  - Backspace now deletes character before cursor position
  - Character input now inserts at cursor position
- Empty command (`:` then Enter) no longer crashes
  - Previously caused error when trying to look up empty string as plugin command
- Buffer word completion now works correctly after opening files with `:e` or `:tabe`
  - `InsertMode` now uses active window's buffer for `BufferWordCache` instead of initial buffer
  - Previously, completion would use stale buffer reference after switching files

## [0.1.0] - 2025-11-30

- Initial release
